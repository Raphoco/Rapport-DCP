\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage{url}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\usepackage{xcolor}
\usepackage{bbm}
\usepackage{amsmath,amssymb}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage{stmaryrd}
\usepackage{systeme}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{pifont}
\usepackage[cache=false]{minted}
\definecolor{LightGray}{gray}{0.95}
\setlength{\parindent}{1cm}

\title{\textsc{compte-rendu}}
\author{PIARD A. - JACQUET R.}
\date{\today}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}
\def\dotfill#1{\cleaders\hbox to #1{.}\hfill}
\newcommand\dotline[2][.5em]{\leavevmode\hbox to #2{\dotfill{#1}\hfil}}

\begin{document}

\begin{titlepage}
	\centering
    \vspace*{0.5 cm}
    \textsc{\LARGE Droit et Conduite de Projet . 2020-2021}\\[1.0 cm]
    \dotline[15pt]{15cm}\\
	\includegraphics[scale = 2.2]{logo.png}
	\dotline[15pt]{15cm}\\
	\vspace{1.5cm}
	\textsc{\Large Faculté des Sciences et Techniques}\\
	\textsc{\large Master 1 - Maths. CRYPTIS}\\[1.0 cm]
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \color{blue} \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{À l'attention de :}\\
			M. CRESPIN\\
			M. DUSART\\
			M. CONCHON\\
		\end{flushleft}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
    	\begin{flushright} \large
		\emph{Rédigé par :}\\
		PIARD A.\\
		JACQUET R.\\
		\phantom{a}\\
		\end{flushright}
	\end{minipage}\\[2 cm]
\end{titlepage}

\tableofcontents
\pagebreak

\section{Introduction et organisation}

\subsection{Introduction}
Le but de notre projet était d'entraîner et de tester les compétences, en terme de programmation, de nos collègues du \textsf{Master 1 Maths CRYPTIS}. Comme énoncé dans notre fiche d'avant-projet, deux \textsl{Competitive Programming Test} étaient prévus, avec les quatre mêmes participants pour chacun d'eux, et nous avions deux protocoles organisationnelles qui s'offraient à nous en vue de la condition sanitaire actuelle. Le protocole ayant été retenu est celui du distanciel.\\
\\
Le premier sujet a été traité le 1er février 2021 et le second le 8 février 2021.

\subsection{Organisation}

Le << recrutement >> des participants s'est fait à distance. Depuis le début de l'année nous avons un groupe Messenger et un serveur Discord pour la promo master 1 maths CRYPTIS $2020$/$2021$. Nous nous sommes orientés à quasiment  100\% sur le Discord, ce qui est bien plus pratique. C'est d'ailleurs Arthur qui avait pris l'initiative de créer ce serveur. C'est donc par cet intermédiaire que nous avons fait une première requête de participants aux alentours du $8$ octobre $2020$. Nous avions lors de cette requête transmis notre fiche d'avant-projet ainsi qu'un appel à candidatures.
\vspace{12pt}\\
Dans les faits, nous n'avons pas eux énormément de retours mais tout de même quelques intéressés. Pour ceux-là et pour d'autres personnes désireuses mais ne s'étant pas prononcé, nous avons organisé un vocal, toujours sur le Discord, pour répondre à leurs éventuels questions et notamment pour les rassurer car certaines personnes n'étaient pas confiantes vis à vis de leurs compétences en programmation.\\
Lorsque nous avons connus les noms de certains participants, Raphaël a créé un autre serveur Discord dans lequel il y a deux groupes de personnes : un groupe pour les participants et un groupe pour les administrateurs, c'est à dire nous. Sur ce Discord il y avait différents salons. Un salon pour rappeler le but de notre projet, un salon pour prévoir d'un jour et d'un créneau horaire satisfaisant le plus de personnes possibles, un salon pour poster les sujets, un salon pour qu'ils postent leur travail en fin de session, un salon pour qu'ils nous posent des questions, etc, ainsi que deux salons vocaux, présents pour les débloquer s'ils avaient un souci lors de l'épreuve.\\

Enfin, pour la rédaction du rapport, nous avons encore une fois fait la majorité du travail en appel sur Discord. Cependant, après chaque fin de session, nous publions l'avancée du rapport sur \textbf{GitHub} de manière à ce que lorsque l'un d'entre nous souhaitait avancer de son côté, il ait la bonne version du rapport. Cela aurait aussi pu nous permettre de retourner sur une version plus ancienne du rapport si nous avions fait des modifications puis changé d'avis.
\pagebreak

\section{Premières réactions}
À l'issue du premier \textsl{Competitive Programming Test}, nous nous sommes rendus compte que les étudiants ont mis beaucoup plus de temps que prévu sur les exercices, ce qui fait qu'aucun d'eux n'a terminé le premier sujet. Il se trouve que les exercices n'étaient pas triés par ordre de difficulté mais qu'ils ont tous choisis de commencer par le premier exercice.\\
Nous les avons légèrement questionnés et aidés à comprendre ce qui n'allait pas, en vue du second \textsl{Competitive Programming Test} qui était prévu la semaine suivante. Celui-ci s'est bien mieux passé. Les étudiants n'ont pas terminés le sujet mais ils ont tous traités au moins un exercice. La plupart des étudiants s'étant intéressés à deux exercices.

\section{Analyse des sujets}
\subsection{Premier sujet}
\subsubsection{Premier exercice}
%Joindre image du sujet
%Dire ce qui semble les avoir gênés, nos réponses apportées, etc

%--- Objectifs du sujet
%--- Comment il a été traité dans l'ensemble
%--- Conclusion de l'expérience de ce sujet

L'objectif principal de ce premier exercice était de mettre l'étudiant face à un chiffré dont la méthode de chiffrement est inconnue. Il a été utilisé deux clés pour chiffrer le message. L'exercice en lui-même n'était pas difficile mais il fallait que l'étudiant tente diverses choses pour comprendre comment le message avait été chiffré. Le chiffrement en question est un chiffrement par substitution (de type César) pour lequel les clés étaient \textsf{3} et \textsf{13}. Malgré les indications, la majorité des étudiants a perdu beaucoup de temps sur cet exercice, ce qui a influé sur l'ensemble du sujet. En effet un étudiant n'a pas pu effectuer l'exercice $2$ et n'a pas trouvé comment résoudre l'exercice $1$.


\subsubsection{Second exercice}

L'objectif de ce second exercice était de développer la méthode de déchiffrement d'un chiffrement précisément décrit. On rappelle que le choix du langage de programmation n'était pas imposé et que suivant le langage utilisé cela est plus ou moins rapide à écrire. Les étapes de l'algorithme étaient bien décomposées mais malgré tout nous n'avons pas eu beaucoup de retours, en raison du temps mal géré par les étudiants lors de l'exercice $1$.

\pagebreak

\subsection{Second sujet}
\subsubsection{Premier exercice}
L'objectif de cet exercice était de programmer l'algorithme de chiffrement écrit en français dans l'énoncé. Les seules difficultés étaient la maîtrise des opérateurs logiques et la conversion de type. Contrairement à nos attentes, cet exercice n'a pas très bien été réussi. Étant donné que l'épreuve a été conduite en distanciel, les étudiants avaient accès à toutes les ressources possibles. Malgré tout, certains n'ont pas su trouver comment effectuer un \textsf{ET Logique}.

\subsubsection{Second exercice}
L'objectif de cet exercice était d'écrire la méthode de déchiffrement à partir de celle qui a permit le chiffrement. Les opérations étaient donc à inverser. Si les étudiants possédaient la bonne fonction, il leur était alors possible de déchiffrer le message. Ici aussi de nombreuses difficultés se sont présentées aux étudiants, comme le passage de tableaux de bits à une chaîne de caractères.

\subsubsection{Troisième exercice}
L'objectif de cet exercice était de déchiffrer un fichier binaire donné. Afin de déchiffrer ce fichier, il fallait trouver la clef de chiffrement qui était écrite sur l'image dont l'extension n'est pas la bonne. Il fallait donc au préalable trouver le bon format d'image avec la commande type \textsf{xxd}, ou \textsf{exiftool}, ou autre. Une fois la clef récupérée il fallait la concaténer autant de fois que nécessaire pour obtenir une taille de clef similaire à la taille du fichier binaire. Enfin il suffisait d'effectuer un \textsf{XOR} entre le fichier binaire et la clef pour obtenir l'image finale. Cet exercice était volontairement légèrement plus difficile et comme attendu il n'a pas été traité.

\pagebreak

\section{Comparaisons entre étudiants}
\subsection{Sujet n°1}
\subsubsection{Premier exercice}

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
import re

chiffre = "IPLU'QV\Ð 'Ç'[VP3'SL'TLZZHNL'JHJOÐ'LZ['A'HGT1GXJ'("

n = len(chiffre)
print(n)
\end{minted}

Ici il est clair que l'étudiant n'a eu aucune idée de comment traiter l'exercice. Du moins il n'en a pas laissé de traces.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3

#EXERCICE 1
alph="abcdefghijklmnopqrstuvwxyzàçéèù"
echantillonfr="Quand, ..."
chif="IPLU'QVnÐ 'Ç'[VP3'SL'TLZZHNL'JHJOÐ'LZ['A'HGT1GXJ'("

def minuscul(texte):
	tmin=texte.lower()
	return [c for c in tmin if c in alph]

def anfreq(chaine):
	dicoccur={}
	for c in chaine:
		if c in dicoccur:
			dicoccur[c]=dicoccur[c]+1
		else:
			dicoccur[c]=1
	listocc=list(dicoccur.items())
	listocc=sorted(listocc,key=lambda t:t[1])
	listocc.reverse()
	return listocc

def replaUN(chaine,dicodéco):
	ecart=ord(dicodéco[0][1]-ord(dicodéco[0][0])
	for x in (0,len(chaine)):
		chaine[x]=chr(ord(chaine[x])+ecart)
	return chaine 
	
# Appels des fonctions (main())
statsfr=anfreq(minuscul(echantillonfr))
statsch=anfreq(chif)
llcl=[t[0] for t in statsfr]
llch=[t[0] for t in statsch]
dicodage=list(zip(llch,llcl))
#print(dicodage)
chclUN=replaUN(chif,dicodage)
\end{minted}

Cet étudiant a eu la bonne idée de faire de l'analyse fréquentielle depuis un texte écrit en français. Grâce à cette méthode, il peut trouver une clef et reconstituer une partie du message. Ensuite, il peut essayer de trouver la seconde clef, compte-tenu du fait qu'il connaît déjà une partie du message, en faisant le déchiffrement à la main. Cet étudiant utilise de nombreuses fonctions Python élémentaires, il maîtrise la gestion de liste, les dictionnaires et les boucles.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3
alphabet = 'abcdefghijklmnopqrstuvwxyz'
# La fréquence d'apparution des lettres varie bien évidemment en fonction
# de la langue et du type de texte
# Pour un texte rédigé en français, on a :
liste_frequence=['e',' ','a','s','i','t','u','r','n'] #quelques lettres 
#par ordre décroisant

chaine=input('chiffré : ')
chaine=chaine.lower()
chaine=[c for c in chaine if c in alphabet]
dico_occurences = {}

def occurence(chaine):
	for c in chaine:
	    if c in dico_occurences:
	        dico_occurences[c] = dico_occurences[c] + 1
	    else:
	        dico_occurences[c] = 1
	print(dico_occurences)

	liste_elements = list(dico_occurences.items())
	liste_elements = sorted(liste_elements,key=lambda t:t[1])
	print(liste_elements)
	dico=dict(liste_elements)
	liste_key=list(dico.keys())

	n=alphabet.index(liste_key[len(liste_key)-1])
	m=alphabet.index('e')
	if n >= m :
		decalage=n-m
	else:
		decalage=m-n
	return decalage

texte_clair=''
decalage=occurence(chaine)
decalage=26-decalage #pour déchiffrer 
alphabet_dechiffrement = alphabet[decalage:] + alphabet[:decalage]
associations = dict(zip(alphabet,alphabet_dechiffrement.upper()))
for c in chaine:
    if c in associations :
        texte_clair += associations[c]
print("############")
print("le message clair : ")
print(texte_clair.lower())
# je parviens pas à continuer !!!!!!
\end{minted}

Cet étudiant a suivi le même raisonnement que le précédent. Son raisonnement arrive au même résultat et en allant un peu plus loin il aurait pu arriver au résultat final. Il maîtrise quand même lui aussi les listes, dictionnaires et les fonctions élémentaires de python.\\
On voit que seulement deux personnes sur quatre ont traités cet exercice ce qui est moins que ce que nous attendions.

\subsubsection{Second exercice}
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!usr/bin/python3
import re
A = """155c04970e1747172e4e070e044e17776e076526
0417474e27330474074e2767072e4e070e9726044f2f776e0407e704272f
0f042e76074e970e4f27047623"""
n = len(A)

def hexad(n): #fonction qui prend transforme un nombre en haxa et 
 # le passe en entier  
	h = 0
	for i in range(len(n)):
		if n[i] == 'a':
			h += 10 * 16**(1-i)
		elif n[i] == 'b':
			h += 11 * 16**(1-i)
		elif n[i] == 'c':
			h += 12 * 16**(1-i)
		elif n[i] == 'd':
			h += 13 * 16**(1-i)
		elif n[i] == 'e':
			h += 14 * 16**(1-i)
		elif n[i] == 'f':
			h += 15 * 16**(1-i)
		else:
			h += int(n[i]) * 16**(1-i)
	return h

def bbinaire(x):
	b = str(bin(x))
	b = b[2:]
	n = len(b)
	if n<8:
		b = (8-n)*'0' + b
	return b

def echange(n):
	if n< 10000000 and n%10 == 1:
		n= n + 10000000 -1
	elif n>1000000 and n%10 == 0:
		n = n - 1000000 +1
	return n

B = []
m = len(B)

for i in range(0,n-1,2):
	B.append(bbinaire(hexad(A[i:i+2])))

#for j in range(m):
#mon but était de faire le chemin inverse avec mes fonctions 

print(B)
\end{minted}

Ici notre étudiant a créé des fonctions qui n'ont pas réellement d'intérêt puisqu'il existe des fonctions élémentaires en python qui permettent, par exemple, de passer d'un entier à sa représentation hexadécimale et vice-versa. La fonction \textsf{bbinaire} permet d'utiliser des octets. Quant à la fonction \textsf{echange}, elle, n'a aucun intérêt. L'étudiant a quand même essayé de faire quelque chose mais ça reste très loin du résultat final.
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3
import sys , re
liste1 = []
liste2 = []
message = """155C04970E1747172E4E070E044E17776E0
765260417474E27330474074E2767072E4E070E9726044F2F776e040
7e704272f0f042e76074e970e4f27047623"""

p = re.compile('\w\w')
liste1 = p.findall(message)

for lettre in liste1 :
	liste2 += bin(int(lettre, 16))

print (liste2)
\end{minted}

Cet étudiant a utilisé les expressions régulières pour récupérer deux à deux les caractères du chiffrés. Il les convertit ensuite en binaire.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3
message = input("Entrez le message à envoyer? : ")
l=len(message)
liste=[]
def gest_caractere(message):
	blocs=[[message[2*i:2*i+2]] for i in range(0,l//2)] 
	#on construit des blocs de 2 elements
	print(blocs)

	for i in range(0,len(blocs)):
		liste.append(blocs[i][0])
	print(liste)
	liste_bin=[bin(int(liste[i], 16)) for i in range(0,len(liste))]
	print(liste_bin)
	#le temps ??????
gest_caractere(message)
\end{minted}
\enlargethispage{2\baselineskip}
\indent Cet étudiant a eu la bonne idée de découper le message en blocs de deux caractères, il les stocke dans une liste qu'il convertit ensuite en une liste de nombres binaires. Les lignes 10 à 12 n'ont aucun intérêt. Il pouvait totalement travailler avec la liste \textsf{blocs}. Toutefois il n'aura effectuer que deux opérations sur la dizaine demandée.\\
L'objectif de cet exercice était pourtant clair, mais il a dû susciter beaucoup d'incompréhension vis à vis de nos étudiants qui ont utilisés beaucoup de fonctions inutiles.

\subsection{Sujet n°2}
\subsubsection{Premier exercice}
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!usr/bin/python3
import os, sys
phrase = 'Il fait beau ce matin.'
phrase = phrase.upper()
PH = []
for u in phrase:
	PH.append(ord(u))
def premf(A):
	for i in range(len(A)):
		if A[i]%3 == 0:
			A[i] += (i+13)%i
	return A
premf(PH)
ch = ""
for i in range(len(PH)):
	ch += chr(PH[i])

CH = bytes(ch, 'utf-8')
ME = []
for i in CH:
	if i%2 ==0:
		ME.append(i^5)
	elif i%3==0:
		ME.append(i|6)
	elif i%5==0:
		ME.append(i&2)
	else:
		ME.append(i)

for i in range(len(ME)):
	ME[i] = chr(ME[i])

mes_fin = ''.join(ME)
print(mes_fin)

# j'obtiens II%CI%GI%CW%MaI[+ 
\end{minted}

Cet étudiant a bien compris le but de cet exercice. Il utilise dans le bon ordre les différentes fonctions et a compris de manière générale les étapes à suivre. Toutefois il a fait des erreurs. Il n'a pas utilisé les bons opérateurs logiques pour obtenir le bon chiffré.
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3
#Exercice 1
message = 'Il fait beau ce matin.'
msg = message.upper()
L = []
for lettre in msg:
    L.append(ord(lettre))
print(L)
L_prime = []
for nombre in L:
    if int(nombre)%3 == 0:
        L_prime.append((int(nombre)+13)%int(nombre))
    else:
        L_prime.append(nombre)
print(L_prime)
#subsidiaire
#chaine = ''
#for nombre in L_prime:
#    c = chr(nombre)
#    print(c)
#    chaine += c    
#subsidiaire
L_bin = []
print(bin(67))

for nombre in L_prime:
    b = bin(nombre)
    if int(nombre)%2 == 0:
        L_bin.append(b[2:len(b)]^101)
    elif int(nombre)%3 == 0:
        L_bin.append(b[2:len(b)] or 110)
    elif int(nombre)%5 == 0:
        L_bin.append(b[2:len(b)] and 10)
    else:
        L_bin.append(b[2:len(b)])
   
print(L_bin)
# NON FINI
\end{minted}

Cet étudiant a lui aussi bien suivi l'ordre de l'algorithme défini, mais il n'a pas terminé son code. Il avait bien compris le but de l'exercice et connaissait ses opérateurs logiques. Toutefois il a fait des erreurs comme la modification des octets suivant la parité de l'index du tableau.
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3
import sys
message = "Il fait beau ce matin."
message = message.upper()
tableau=[]

for i in range(0, len(message)) :
	tableau.append(ord(message[i]))
	if(tableau[i]%3==0):
		tableau[i]+= (13+i)%i
for i in range(0, len(message)-1) :
	if(i%2==0):
		tableau[i] = tableau[i]^5
	if(i%3==0):
		newl=""
		l = bin(tableau[i])
		for j in range(0, len(l)-3):
			newl += l[j]
		newl +="11"
		newl += l[len(l)-1]
		tableau[i] = int(newl, 2)
	if(i%5==0):
		newl=""
		l = bin(tableau[i])
		for j in range(0, len(l)-3):
			newl += l[j]
		newl +="0"
		newl += l[len(l)-2]
		newl +="0"
		tableau[i] = int(newl, 2)
l = ""
for i in range(0, len(message)-1) :
	l += chr(tableau[i])

print(l) #JL%FDHV BO@U'CW"HAfIZ
\end{minted}

Cet étudiant a presque le bon résultat. Sa méthodologie est bonne mais ses opérations logiques sont mal effectuées. En effet, il faut les faire avec des bits. La chaîne "110" n'est pas le bit $110$. Avec un peu plus de rigueur et d'attention, cet étudiant aurait obtenu le bon chiffré. Il est quand même important de souligner que tout le reste est correct.
\pagebreak
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3

message='il fait beau ce matin'
message=message.upper()
#print(message)
tableau=[ord(i) for i in message]
print(tableau)
for i in range(0,len(tableau)):
	if tableau[i]%3==0:
		tableau[i]=tableau[i]+(13+i)%i 
#print(tableau)
tableau_caract=[chr(i) for i in tableau]
print(tableau_caract)
chaine=''.join(tableau_caract)
print(chaine)
tableau_oct=[bin(ord(i))[2:] for i in chaine]
print(tableau_oct[0])
for i in range(0,len(tableau_oct)):
	if tableau[i]%2==0:
		tableau[i]=tableau[i]^int('101',2)
	if tableau[i]%3==0:
		tableau[i]=tableau[i]|int('110',2)
	if tableau[i]%5==0:
		tableau[i]=tableau[i]&int('010',2)
#print(tableau)
chaine_f=[chr(i) for i in tableau]
chaine_f=''.join(chaine_f)
print(chaine_f)
\end{minted}

Cet étudiant a une excellente méthodologie, il a bien suivi l'énoncé. La seule erreur notable est la mauvaise écriture des opérateurs logiques en python. En dehors de cette erreur, le code est totalement correct.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3
#EXERCICE 1
txt="Il fait beau ce matin."
#1
TXT=txt.upper()
#2 et 3
tab=[]

for i in range(0,len(txt)):
	tab.append(ord(txt[i]))
	if tab[i]%3==0:
		tab[i]=tab[i]+((13+i)%i)
#4
rst=""

for i in range(0,len(tab)):
	rst=rst+chr(tab[i])
#5
loct=list(map(bin,rst.encode('utf-8')))
#6
def tabmodif(ta):é
	for i in range(0,len(ta)):
		if i%2==0:
			ta[i]=ta[i]^101
		if i%3==0:
			ta[i]=ta[i] (ou inclusif) 110
		if i%5==0:
			ta[i]=ta[i] (et) 010
	return ta
#7
#Si fait avec la liste du 3)
rslt=""

for i in range(0,len(tab))
	rslt=rslt+chr(tab[i])

#Si fait avec liste du 5)
rsltat=""
for i in range(0,len(loct)):
	rsltat=rsltat+bytes([int(loct[i],2)]).decode('utf-8')
\end{minted}

Cet étudiant était sur la bonne piste mais il n'a pas été au bout de la réflexion et a manqué de rigueur sur la rédaction du code. On remarque qu'il ne connaît ni les opérateurs logiques ni la conversion chaîne de caractères vers bits. Même après "correction" du code, le résultat n'est pas du tout celui attendu.
Les légères corrections apportées étaient nécessaires pour pouvoir exécuter le programme. Autrement, les lignes de code de l'étudiant n'ont pas été modifiées.

\pagebreak

\subsubsection{Second exercice}
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!usr/bin/python3
import os, sys
ph="FC?E^FK?YZ^J?XZ?B^KFM-"
S = bytes(ph,'utf-8')
A = []
for u in S:
	A.append(chr((u^21)-10))
phrase = ''.join(A)
print(phrase)
# résultat = IL FAIT BEAU CE MATIN.
\end{minted}

Cet étudiant a réussi l'exercice. Il a même prit l'initiative d'utiliser le \textsf{xor} entre entiers, ce qui fonctionne avec python. Il obtient le bon résultat ce qui est satisfaisant.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3
#Exercice 2
message = 'FC?EˆFK?YZˆJ?XZ?BˆKFM-'
L = []
for lettre in message:
    L.append(ord(lettre) + 10)
print(L)
msg = ''
for i in L:
    msg += chr(i)
print(msg)
# NON FINI
\end{minted}

Cet étudiant n'a effectué que les trois premières étapes, sûrement par faute de temps. Il était toutefois sur la bonne voie. Les premières lignes de codes sont justes.

\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#!/usr/bin/python3
import sys
message = "FC?E^FK?YZ^J?XZ?B^KFM"
dechiffre = ""
for i in range(0, len(message)) :
	dechiffre += chr((ord(message[i])^21)-10)
print(dechiffre) #IL FAIT BEAU CE MATIN
\end{minted}

Cet étudiant a également réussi l'exercice et de façon encore plus compacte. Il n'y a pas grand chose à redire, sa maîtrise du \textsf{XOR} entre entiers est intéressante.\\
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{python}
#Chiffrement:
chif='FC?E^FK?YZ^J?XZ?B^KFM-'
tabl=[]
chaine=""
for i in range(0,len(chif)):
	tabl.append(ord(chif[i])+10)
	chaine=chaine+chr(tabl[i])
lisoct=list(map(bin,chaine.encode('utf-8')))
for i in range(0,len(lisoct)):
	lisoct[i]=lisoct[i]^10101
retout=""
for i in range(0,len(lisoct)):
	retour=retour+bytes([int(lisoct[i],2)]).decode('utf-8')
#Déchiffrement
byt=list(map(bin,chif.encode('utf-8')))
inter=""
clair=""
for i in range(0,len(byt)):
	byt[i]=byt[i]^10101
	inter=inter+bytes([int(byt[i],2)]).decode('utf-8')
t=[]
for i in range(0,len(inter)):
	t.append(ord(inter[i]))
	t[i]=t[i]-10
	clair=clair+chr(t[i])
\end{minted}

Cet étudiant a essayé de coder la méthode de chiffrement, ce qui était inutile. Peut-être espérait-il que ça l'aiderait. Ceci étant, sa méthode de chiffrement ne marche pas. En effet, il a tenté d'effectuer un \textsf{XOR} entre deux types différents à la ligne $10$.\\

Pour le déchiffrement il a effectué la même erreur, c'est à dire un \textsf{XOR} entre deux types différents (à la ligne $19$) donc sa méthode ne marche pas. Cela dit, hormis cette erreur importante, le reste du programme semble correct.
\subsubsection{Troisième exercice}

A notre plus grand regret cet exercice n'a pas été traité. Cela aurait été un bon moyen de départager les étudiants et c'est celui qui ressemblait le plus à un CTF (Capture The Flag).

\subsection{Conclusions}

\subsubsection{Conclusion de Raphaël}

Le choix de mon binôme était assez naturel. Nous nous connaissons bien avec Arthur et j'ai le sentiment que nous réussissons à travailler ensemble. L'idée du \textbf{Competitive Programming Test} nous est venue assez rapidement. Celle-ci ayant émergée principalement en raison de mon attrait pour la programmation qui s'est un petit peu plus développé suite aux séances de travaux pratiques du module \textsf{Réseau et Système}, et suite à la découverte des \textsf{Capture The Flag}.\\
Nous avons donc chacun créés des exercices de programmation relativement basiques mais utilisant des notions de cryptographie. Arthur en avait fait en Java et de mon côté en Python. Nous avions chacun essayé de ré-écrire les programmes de l'autre, dans le langage que nous avions utilisé, pour voir approximativement le temps nécessaire à leur écriture, et ainsi pour faire des sujets cohérents avec le temps imparti pour ces derniers.\\
Nous nous échangions les fichiers par notre conversation personnelle sur Discord. Pour l'écriture des sujets, nous avons profité de ma présence sur Limoges pour se voir et donc les rédiger. Bien que les exercices étaient déjà prêts. Étant parti de Limoges après les examens de janvier, nous avons arrangé les détails par appel sur Discord en partage d'écran. \\
Enfin, pour l'organisation avec les autres étudiants, nous avions lancé un appel à candidatures sur le serveur Discord de notre promotion, qui avait été créé par Arthur au début de l'année. Une fois que nous avons eu suffisamment de participants, nous avons créés un nouveau serveur Discord pour que l'on se retrouve tous et que la préparation des épreuves et leur déroulement y soit simplifié.\\
Pour conclure, c'est un projet qui s'est bien déroulé. Autant au niveau de notre binôme qu'avec les autres étudiants qui semblent avoir apprécié participer et progressé. Le partage des tâches et notre bonne entente ont permit de bien mener ce projet, sachant que la plupart de nos sessions de travail se sont déroulées en appel et partage d'écran.

\subsubsection{Conclusion d'Arthur}
\enlargethispage{3\baselineskip}
Pour ma part j'ai apprécié faire ce projet dirigé conjointement avec Raphaël. Mon intérêt pour la programmation diverse et les diverses sessions de travaux pratique lors du premier semestre a fait naître cette idée de confronter des étudiants à des exercices de programmations divers et variés utilisant la programmation pure comme la réflexion cryptographique. La création des sujets a été une partie assez intéressante et ludique. Il fallait trouver le bon équilibre sur la difficulté. Raphaël et moi avions fait les corrections pour sa part en \textbf{Python} et moi-même en \textbf{Java}. Cela permettait de voir les avantages et éventuellement inconvénients sur ces différents langages. Malgré les circonstances qui n'étaient très clairement pas optimales, nous avons pu nous débrouiller grâce à la plateforme \textbf{Discord} et organiser ces épreuves à distance. Je suis un peu déçu du peu de résultat pour quelques sujets mais je pense que le stress et/ou une mauvaise organisation du temps peuvent mener quelques fois à des échecs. 
Malgré tout j'étais très content d'avoir pu participer à la création de ce projet et les retours des étudiants testés étaient bons donc je peux considérer que ce projet s'est bien déroulé.

\subsubsection{Conclusion générale}

Les prémices de ce projet ont été de choisir des étudiants du \textsf{Master Maths. CRYPTIS} exclusivement. Notre choix s'est porté sur des étudiants avec des profils très différents et chacun avec leurs spécificités. Il aurait été trop facile de choisir des étudiants de la filière informatique du \textsf{Master CRYPTIS}.\\
Il est clair que les étudiants ont été moins productif que ce nous attendions. Mais, a posteriori, lorsque l'on compare ce qu'ils ont fait en ce début de semestre 2 et aujourd'hui avec les travaux pratiques auxquels nous assistons, il y a une différence notable.\
En effet, leur niveau est pour la majorité à la hausse. Cela s'explique par un conditionnement et une pratique plus régulière de l'algorithmique générale. La matière \textsf{Sécurité TIC} qui utilise les notions de \textbf{Python} vues au premier semestre et l'utilisation de nouvelles bibliothèques comme \textbf{OpenSSL} n'est pas un problème pour eux. Ils arrivent beaucoup mieux à suivre les étapes et à traduire les énoncés en lignes de code. Nous avons beaucoup discutés avec les étudiants testés après les \textbf{CPT}.\\
En leur expliquant les subtilités et les cheminements d'idées nécessaire à la bonne résolution de tel ou tel exercice, nous pensons fortement avoir augmenté leur niveau en programmation, ce qui était le but recherché.\\
Nous avons apprécié ce type de projet en autonomie. Avec la situation sanitaire plus que complexe durant ce second semestre nous avons dû nous organiser autrement et faire les épreuves en distanciel. Cela n'a pas été idéal pour nous comme pour les étudiants mais nous sommes satisfait du résultat. Comme conclusion plus globale nous pouvons tirer comme enseignement que les étudiants ayant fait peu voir jamais d'informatique (orientée programmation) pendant leur cycle de Licence seront nécessairement plus en difficulté dans le cursus \textsf{Maths. CRYPTIS}. Nous recommandons donc aux futurs promotions de travailler, seul, ou bien avec toutes les ressources qu'Internet propose, leurs bases en programmation.

\pagebreak

\end{document}
